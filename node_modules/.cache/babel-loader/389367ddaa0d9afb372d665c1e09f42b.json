{"ast":null,"code":"var _jsxFileName = \"/Users/liwentian/Desktop/intern/slackapp/src/performance/components/Calculate.js\";\nimport React from 'react';\nimport PerformanceItem from './PerformanceItem';\nimport { differenceInCalendarMonths } from 'date-fns';\n\nconst Calculate = props => {\n  let dict = {};\n  var last = new Date(new Date().getTime() - (4 * 24 * 60 * 60 * 1000 + 11 * 60 * 60 * 1000));\n  props.items.map(item => {\n    if (!dict.hasOwnProperty(item.userid)) {\n      dict[item.userid] = {\n        \"name\": item.name,\n        \"status\": [],\n        \"time\": [],\n        \"totaltime\": \"\"\n      };\n    } //date has to be in range 5 days\n\n\n    var datetime = item.time;\n    var d = new Date(datetime); // console.log(last);\n\n    if (d.getTime() >= last.getTime()) {\n      // console.log(d);\n      //compare the first active and the first away\n      //active < away ->  away - active\n      //active > away -> away - start + (one more away - start) \n      if (dict[item.userid].status.length >= 1 && item.status == dict[item.userid].status[dict[item.userid].status.length - 1]) {\n        dict[item.userid].time[dict[item.userid].time - 1] = d;\n      } else {\n        dict[item.userid].status.push(item.status);\n        dict[item.userid].time.push(d);\n      } // dict[item.userid].status.push(item.status);\n      // dict\n      // if(item.status == \"away\"){\n      //     dict[item.userid].away.push(d);\n      // }else if(item.status == \"active\"){\n      //     dict[item.userid].active.push(d);\n      // }\n\n    }\n  }); //go through the dict again and calculate the total time\n\n  Object.keys(dict).forEach(function (key) {\n    var status = dict[key].status;\n    var time = dict[key].time; // if(away.length == 0 || active.length == 0){\n    //     if(away.length!=0){\n    //         dict[key].totaltime = \"always away\";\n    //     }else if(active.length!=0){\n    //         dict[key].totaltime = \"always active\";\n    //     }\n\n    if (status.length == 1) {\n      if (status[0].equals(\"away\")) {\n        dict[key].totaltime = \"always away\";\n      } else {\n        dict[key].totaltime = \"always active\";\n      }\n    } else if (status[0].equals(\"active\")) {\n      var totaltime = 0;\n      var first = time[0].getTime();\n\n      for (var i = 0; i < time.length; i++) {\n        if (i % 2 == 0) {\n          first = time[i].getTime();\n        } else {\n          totaltime += time[i].getTime() - first;\n          first = 0;\n        }\n      }\n\n      if (first != 0) {\n        //still have one active left\n        totaltime += new Date().getTime() - first;\n      }\n\n      dict[key].totaltime = (totaltime / 3600000).toFixed(2).toString() + \"h\";\n    } else if (status[0].equals(\"away\")) {\n      var totaltime = time[0].getTime() - last.getTime();\n      var first = time[1].getTime();\n\n      for (var i = 1; i < time.length; i++) {\n        if (i % 2 == 1) {\n          first = time[i].getTime();\n        } else {\n          totaltime += time[i].getTime();\n          first = 0;\n        }\n      }\n\n      if (first != 0) {\n        totaltime += new Date().getTime() - first;\n      }\n\n      dict[key].totaltime = (totaltime / 3600000).toFixed(2).toString() + \"h\";\n    }\n  }); // }else if (active[0].getTime() < away[0].getTime()){\n  //     var activeindex = 0;\n  //     var awayindex = 0;\n  //     var totaltime = 0;\n  //     while(activeindex < active.length && awayindex < away.length){\n  //         totaltime+= away[awayindex].getTime() - active[activeindex].getTime();\n  //         awayindex++;\n  //         activeindex++;\n  //     }\n  //    if(activeindex < active.length){\n  //        totaltime += new Date().getTime() - active[activeindex].getTime();\n  //    }\n  //    if(awayindex < away.length){\n  //        totaltime += away[awayindex].getTime() - active[active.length-1].getTime();\n  //    }\n  //    dict[key].totaltime = (totaltime / 3600000).toFixed(2).toString() + \"h\";\n  // }else{\n  //active > away -> away - start + (one more away - start) \n  //  var totaltime = 0;\n  //  var activeindex = 0;\n  //  var awayindex = 1;\n  //  console.log(away[0]);\n  //  console.log(last);\n  //  console.log(totaltime/3600000);\n  //  while(activeindex < active.length && awayindex < away.length){\n  //     totaltime+= away[awayindex].getTime() - active[activeindex].getTime();\n  // console.log(totaltime);\n  //     awayindex++;\n  //     activeindex++;\n  //  }\n  //  if(activeindex < active.length){\n  //     totaltime += new Date().getTime() - active[activeindex].getTime();\n  // }\n  // if(awayindex < away.length){\n  //     totaltime += away[awayindex].getTime() - active[active.length-1].getTime();\n  // }\n  // console.log(totaltime);\n  //         dict[key].totaltime = (totaltime / 3600000).toFixed(2).toString() + \"h\";\n  //     }             \n  // });\n  // console.log(dict);\n\n  return Object.entries(dict).map(([key, value]) => React.createElement(\"p\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 137\n    },\n    __self: this\n  }, \" \", value.name, \": \", value.totaltime));\n};\n\nexport default Calculate;","map":{"version":3,"sources":["/Users/liwentian/Desktop/intern/slackapp/src/performance/components/Calculate.js"],"names":["React","PerformanceItem","differenceInCalendarMonths","Calculate","props","dict","last","Date","getTime","items","map","item","hasOwnProperty","userid","name","datetime","time","d","status","length","push","Object","keys","forEach","key","equals","totaltime","first","i","toFixed","toString","entries","value"],"mappings":"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","sourcesContent":["import React from 'react';\n\nimport PerformanceItem from './PerformanceItem';\nimport { differenceInCalendarMonths } from 'date-fns';\n\n\n\nconst Calculate = props => {\n    let dict = {};\n    var last = new Date(new Date().getTime() - (4 * 24 * 60 * 60 * 1000 + 11 * 60 * 60 * 1000));\n    props.items.map(item=>{\n        if(!dict.hasOwnProperty(item.userid)){\n            dict[item.userid] = {\"name\":item.name,\"status\":[],\"time\":[],\"totaltime\":\"\"};\n        }\n        \n        //date has to be in range 5 days\n\n        var datetime = item.time;\n\n        var d = new Date(datetime);\n        // console.log(last);\n        if(d.getTime() >= last.getTime()){\n            // console.log(d);\n            //compare the first active and the first away\n            //active < away ->  away - active\n            //active > away -> away - start + (one more away - start) \n            if(dict[item.userid].status.length >= 1 && item.status == dict[item.userid].status[dict[item.userid].status.length-1]){\n                dict[item.userid].time[dict[item.userid].time-1] = d;\n            }else{\n                dict[item.userid].status.push(item.status);\n                dict[item.userid].time.push(d);\n            }\n            // dict[item.userid].status.push(item.status);\n            // dict\n            // if(item.status == \"away\"){\n            //     dict[item.userid].away.push(d);\n            // }else if(item.status == \"active\"){\n            //     dict[item.userid].active.push(d);\n            // }\n        }\n      \n       \n    })\n    //go through the dict again and calculate the total time\n    Object.keys(dict).forEach(function(key) {\n        var status = dict[key].status;\n        var time = dict[key].time;\n        // if(away.length == 0 || active.length == 0){\n        //     if(away.length!=0){\n        //         dict[key].totaltime = \"always away\";\n        //     }else if(active.length!=0){\n        //         dict[key].totaltime = \"always active\";\n        //     }\n        if(status.length == 1){\n            if(status[0].equals(\"away\")){\n                dict[key].totaltime = \"always away\";\n            }else{\n                dict[key].totaltime = \"always active\";\n            }\n        }else if(status[0].equals(\"active\")){\n            var totaltime = 0;\n            var first = time[0].getTime();\n            for(var i = 0; i < time.length;i++){\n                if(i % 2 == 0){\n                  first = time[i].getTime();\n                }else{\n                  totaltime += time[i].getTime() - first;\n                  first = 0;\n                }\n            }\n            if(first != 0){\n                //still have one active left\n                totaltime += new Date().getTime() - first;\n            }\n            dict[key].totaltime = (totaltime / 3600000).toFixed(2).toString() + \"h\";\n        }else if(status[0].equals(\"away\")){\n            var totaltime = time[0].getTime() - last.getTime();\n            var first = time[1].getTime();\n            for(var i = 1; i < time.length; i++){\n               if(i % 2 == 1){\n                   first = time[i].getTime();\n               }else{\n                   totaltime += time[i].getTime();\n                   first = 0;\n               }\n            }\n            if(first!=0){\n                totaltime += new Date().getTime() - first;\n            }\n            dict[key].totaltime = (totaltime / 3600000).toFixed(2).toString() + \"h\";\n        }\n    })\n        // }else if (active[0].getTime() < away[0].getTime()){\n        //     var activeindex = 0;\n        //     var awayindex = 0;\n        //     var totaltime = 0;\n        //     while(activeindex < active.length && awayindex < away.length){\n        //         totaltime+= away[awayindex].getTime() - active[activeindex].getTime();\n        //         awayindex++;\n        //         activeindex++;\n        //     }\n        //    if(activeindex < active.length){\n        //        totaltime += new Date().getTime() - active[activeindex].getTime();\n        //    }\n        //    if(awayindex < away.length){\n        //        totaltime += away[awayindex].getTime() - active[active.length-1].getTime();\n        //    }\n        //    dict[key].totaltime = (totaltime / 3600000).toFixed(2).toString() + \"h\";\n        // }else{\n             //active > away -> away - start + (one more away - start) \n            //  var totaltime = 0;\n            //  var activeindex = 0;\n            //  var awayindex = 1;\n            //  console.log(away[0]);\n            //  console.log(last);\n            //  console.log(totaltime/3600000);\n            //  while(activeindex < active.length && awayindex < away.length){\n            //     totaltime+= away[awayindex].getTime() - active[activeindex].getTime();\n                // console.log(totaltime);\n            //     awayindex++;\n            //     activeindex++;\n            //  }\n            //  if(activeindex < active.length){\n            //     totaltime += new Date().getTime() - active[activeindex].getTime();\n            // }\n            // if(awayindex < away.length){\n            //     totaltime += away[awayindex].getTime() - active[active.length-1].getTime();\n            // }\n            // console.log(totaltime);\n    //         dict[key].totaltime = (totaltime / 3600000).toFixed(2).toString() + \"h\";\n    //     }             \n    // });\n    // console.log(dict);\n\n    \n  return (\n     Object.entries(dict).map( ([key, value]) => <p> {value.name}: {value.totaltime}</p> )\n  ) \n};\n\nexport default Calculate;\n"]},"metadata":{},"sourceType":"module"}