{"ast":null,"code":"var _jsxFileName = \"/Users/liwentian/Desktop/intern/slackapp/src/performance/components/Calculate.js\";\nimport React from 'react';\nimport PerformanceItem from './PerformanceItem';\nimport { differenceInCalendarMonths } from 'date-fns';\n\nconst Calculate = props => {\n  let dict = {};\n  var last = new Date(new Date().getTime() - (4 * 24 * 60 * 60 * 1000 + 11 * 60 * 60 * 1000));\n  props.items.map(item => {\n    if (!dict.hasOwnProperty(item.userid)) {\n      dict[item.userid] = {\n        \"name\": item.name,\n        \"away\": [],\n        \"active\": [],\n        \"totaltime\": \"\"\n      };\n    } //date has to be in range 5 days\n\n\n    var datetime = item.time;\n    var d = new Date(datetime); // console.log(last);\n\n    if (d.getTime() >= last.getTime()) {\n      // console.log(d);\n      //compare the first active and the first away\n      //active < away ->  away - active\n      //active > away -> away - start + (one more away - start) \n      if (item.status == \"away\") {\n        dict[item.userid].away.push(d);\n      } else if (item.status == \"active\") {\n        dict[item.userid].active.push(d);\n      }\n    }\n  }); //go through the dict again and calculate the total time\n\n  Object.keys(dict).forEach(function (key) {\n    var away = dict[key].away;\n    var active = dict[key].active;\n\n    if (away.length == 0 || active.length == 0) {\n      if (away.length != 0) {\n        dict[key].totaltime = \"always away\";\n      } else if (active.length != 0) {\n        dict[key].totaltime = \"always active\";\n      }\n    } else if (active[0].getTime() < away[0].getTime()) {\n      var activeindex = 0;\n      var awayindex = 0;\n      var totaltime = 0;\n\n      while (activeindex < active.length && awayindex < away.length) {\n        totaltime += away[awayindex].getTime() - active[activeindex].getTime();\n        awayindex++;\n        activeindex++;\n      }\n\n      if (activeindex < active.length) {\n        totaltime += new Date().getTime() - active[activeindex].getTime();\n      }\n\n      if (awayindex < away.length) {\n        totaltime += away[awayindex].getTime() - active[activeindex.length - 1].getTime();\n      }\n\n      dict[key].totaltime = (totaltime / 3600000).toFixed(2).toString() + \"h\";\n    } else {\n      //active > away -> away - start + (one more away - start) \n      var totaltime = 0;\n      var activeindex = 0;\n      var awayindex = 1; //  console.log(away[0]);\n      //  console.log(last);\n      //  console.log(totaltime/3600000);\n\n      while (activeindex < active.length && awayindex < away.length) {\n        totaltime += away[awayindex].getTime() - active[activeindex].getTime(); // console.log(totaltime);\n\n        awayindex++;\n        activeindex++;\n      }\n\n      if (activeindex < active.length) {\n        totaltime += new Date().getTime() - active[activeindex].getTime();\n      }\n\n      if (awayindex < away.length) {\n        totaltime += away[awayindex].getTime() - active[activeindex.length - 1].getTime();\n      } // console.log(totaltime);\n\n\n      dict[key].totaltime = (totaltime / 3600000).toFixed(2).toString() + \"h\";\n    }\n  }); // console.log(dict);\n\n  return React.createElement(React.Fragment, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 90\n    },\n    __self: this\n  }, React.createElement(\"h1\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 91\n    },\n    __self: this\n  }), \"Object.entries(dict) .map( ([key, value]) => \", React.createElement(\"p\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 93\n    },\n    __self: this\n  }, key, \" \", value.name, \": \", value.totaltime), \" )\");\n};\n\nexport default Calculate;","map":{"version":3,"sources":["/Users/liwentian/Desktop/intern/slackapp/src/performance/components/Calculate.js"],"names":["React","PerformanceItem","differenceInCalendarMonths","Calculate","props","dict","last","Date","getTime","items","map","item","hasOwnProperty","userid","name","datetime","time","d","status","away","push","active","Object","keys","forEach","key","length","totaltime","activeindex","awayindex","toFixed","toString","value"],"mappings":"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","sourcesContent":["import React from 'react';\n\nimport PerformanceItem from './PerformanceItem';\nimport { differenceInCalendarMonths } from 'date-fns';\n\n\n\nconst Calculate = props => {\n    let dict = {};\n    var last = new Date(new Date().getTime() - (4 * 24 * 60 * 60 * 1000 + 11 * 60 * 60 * 1000));\n    props.items.map(item=>{\n        if(!dict.hasOwnProperty(item.userid)){\n            dict[item.userid] = {\"name\":item.name,\"away\":[],\"active\":[],\"totaltime\":\"\"};\n        }\n        \n        //date has to be in range 5 days\n\n        var datetime = item.time;\n\n        var d = new Date(datetime);\n        // console.log(last);\n        if(d.getTime() >= last.getTime()){\n            // console.log(d);\n            //compare the first active and the first away\n            //active < away ->  away - active\n            //active > away -> away - start + (one more away - start) \n            if(item.status == \"away\"){\n                dict[item.userid].away.push(d);\n            }else if(item.status == \"active\"){\n                dict[item.userid].active.push(d);\n            }\n        }\n      \n       \n    })\n    //go through the dict again and calculate the total time\n    Object.keys(dict).forEach(function(key) {\n        var away = dict[key].away;\n        var active = dict[key].active;\n        if(away.length == 0 || active.length == 0){\n            if(away.length!=0){\n                dict[key].totaltime = \"always away\";\n            }else if(active.length!=0){\n                dict[key].totaltime = \"always active\";\n            }\n        }else if (active[0].getTime() < away[0].getTime()){\n            var activeindex = 0;\n            var awayindex = 0;\n            var totaltime = 0;\n            while(activeindex < active.length && awayindex < away.length){\n                totaltime+= away[awayindex].getTime() - active[activeindex].getTime();\n                awayindex++;\n                activeindex++;\n            }\n           if(activeindex < active.length){\n               totaltime += new Date().getTime() - active[activeindex].getTime();\n           }\n           if(awayindex < away.length){\n               totaltime += away[awayindex].getTime() - active[activeindex.length-1].getTime();\n           }\n           dict[key].totaltime = (totaltime / 3600000).toFixed(2).toString() + \"h\";\n        }else{\n             //active > away -> away - start + (one more away - start) \n             var totaltime = 0;\n             var activeindex = 0;\n             var awayindex = 1;\n            //  console.log(away[0]);\n            //  console.log(last);\n            //  console.log(totaltime/3600000);\n             while(activeindex < active.length && awayindex < away.length){\n                totaltime+= away[awayindex].getTime() - active[activeindex].getTime();\n                // console.log(totaltime);\n                awayindex++;\n                activeindex++;\n             }\n             if(activeindex < active.length){\n                totaltime += new Date().getTime() - active[activeindex].getTime();\n            }\n            if(awayindex < away.length){\n                totaltime += away[awayindex].getTime() - active[activeindex.length-1].getTime();\n            }\n            // console.log(totaltime);\n            dict[key].totaltime = (totaltime / 3600000).toFixed(2).toString() + \"h\";\n        }             \n    });\n    // console.log(dict);\n\n    \n  return (\n    <React.Fragment>\n     <h1></h1>\n     Object.entries(dict)\n    .map( ([key, value]) => <p>{key} {value.name}: {value.totaltime}</p> )\n    </React.Fragment>\n\n  ) \n};\n\nexport default Calculate;\n"]},"metadata":{},"sourceType":"module"}